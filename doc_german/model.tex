\section{Datenmodell}
\label{datenmodell}

Die Datenstruktur kann in einem einfach gehaltenen \textit{UML-Klassendiagramm}\ref{fig:uml_diagram} dargestellt werden. Im Wesentlichen enthält die Basis-Entität \texttt{Reference}  grundlegendene Container-Attribute, die wiederum mit Informationen angereichert wurden. Die Datenstruktur wird in diesem Kapitel kurz erläutert.

\input{model_uml.tex}

\subsection{Reference-Containerklasse}
Den übergeordneten Datencontainer bildet die \texttt{Reference}-Klasse, sie hält zwei Attribute:

\begin{enumerate}
   \item Das \texttt{location}-Attribut beinhaltet eine Instanz der \texttt{OSM::Location}-Klasse. 
   \item Das \texttt{discoveries}-Attribut hält eine Liste von \texttt{Discovery}-Instanzen. 
\end{enumerate}

Eine Georeferenz, also eine Instanz der hier beschriebenen \texttt{Reference}-Klasse, liefert dementsprechend einen Verweis auf einen geografisch real existierenden Ort auf der Welt und eine Liste von Hinweisen, wie und wo diese Referenz durch etwaige Suchalgorithmen in Webdokumenten gefunden und entsprechend referenziert wurde.

\subsection{OSM::Location: OpenStreetMaps-basierte Ortsangabe}
Die \texttt{OSM::Location}-Instanz stellt eine stark vereinfachte Abstraktion einer OpenStreetMaps \texttt{Node}\cite{OSMnode} dar. Im OpenStreetMaps-Datenmodell repräsentieren Nodes einen distinkten Punkt, der innerhalb von OpenStreetMaps einzigartig ist und mit Positionsdaten versehen ist. In unserem Datenmodell sind die exakten Geokoordinaten nicht von essentieller Wichtigkeit (weil der Fokus eher auf Städten, Regionen oder Ländern liegt, wichtig ist uns die Bennenbarkeit eines Ortes, nicht dessen Lage), daher persistieren wir in der \texttt{OSM::Location}-Instanz lediglich \ldots

\begin{enumerate}
  \item die \texttt{node\_id}, sowie 
  \item einen menschenlesbaren Namen (Attribut \texttt{human\_readable\_name}) und 
  \item den \textit{Administration-Level}-Wert von OpenStreetMaps\cite{OSMadminlevel} (Attribut \texttt{administrative\_level}). 
\end{enumerate}

Mit Letzterem kann bestimmt werden, ob es sich bei der benannten Georeferenz etwa um einen Kontinent, einen Staat, ein Bundesland oder eine Stadt handelt.

\subsection{Inhaltliche Beschreibung einer Georeferenz: Discovery-Klasse}
Die \texttt{Reference}-Klasse enthält wie erwähnt eine Liste von \texttt{Discovery}-Instanzen. In einer \texttt{Discovery}-Instanz wird festgehalten, \textit{wo} (Attribut: \texttt{source}, Instanz einer \texttt{Discovery::Source}-Klasse) und in welchem \textit{zeitlichen Rahmen} (Attribut \texttt{time}, Instanz einer \texttt{Discovery::Time}-Klasse) diese Georeferenz an dem durch die \texttt{OSM::Location}-Klasse konkret festgelegten Ort referenziert wird. Weiterhin gibt es eine \texttt{Discovery::Locator}-Klasse, die die Rückverfolgbarkeit der Quelle sicherstellt. Die einzelnen Discovery-Komponenten werden im Folgenden noch genauer geschrieben.

\subsubsection{Informationen zur Quelle: Discovery::Source}
Die \texttt{Discovery::Source}-Klasse ist ein Container für zwei Attribute: Zum einen hält ein \texttt{identifier} eine Referenz auf eine konkrete Datenquelle vor, beispielsweise \textit{dbp} für DBpedia. Zum anderen hält der \texttt{trustworthiness}-Wert eine Einschätzung für die Zuverlässigkeit der Quelle vor. Beide Attribute ergeben sich aus dem Anwendungsfall und müssen pro Anwendung konfigurierbar gehalten sein. Der \texttt{trustworthiness}-Wert enthält Werte einer Likert-Skala (von ``Sehr vertrauenswürdig'' bis ``Nicht vertrauenswürdig''), intern könnten die Werte dieser Skala auf Ganzzahlen (oder Enumeration-Werte) abgebildet werden, allerdings verbietet sich das Rechnen auf Likert-Skalen aus den auf Seite \pageref{calc_likert} genannten Gründen.

\subsubsection{Zeitreferenz: Discovery::Time}
Die \texttt{Discovery::Time}-Klasse ist ein Container für die beiden Attribute \texttt{representation} und \texttt{estimated\_precision}. Der erste Wert gibt eine konkrete, wörtliche Beschreibung einer Zeitangabe wieder (also beispielsweise ``1990ies'', ``1997'' oder ``1990-1996''). Der zweite Wert gibt auf einer Likert-Skala (von ``sehr präzise'' bis ``sehr unpräzise'') eine Einschätzung über die Genauigkeit der Zeitangabe - in Hinblick auf den Anwendungsfall - an. So wäre beispielsweise im Rahmen einer Epochenbeschreibung eine Jahresangabe ``sehr präzise'' und eine Angabe eines Jahrtausends ``sehr unpräzise''. Selbige Einschränkungen wie oben beschrieben in Hinblick auf die Likert-Skalen gelten auch hier. Die Einschätzung der Präzision muss ein, die Datenstruktur befüllender, Algorithmus liefern. Hintergrund ist, dass die Feinjustierung dieser Einschätzung von Anwendungsfall zu Anwendungsfall unterschiedlich sein kann. So wird es Szenarien geben, in denen konkrete Tages-Angaben von Bedeutung sind, andererseits wird es Fälle geben, in denen Jahresangaben oder sogar Jahrzehnte ``präzise'' genug sind. Auch hier ist also die Konfigurierbarkeit essentiell.

\subsubsection{Spezifizierung der Fundstelle: Discovery::Locator}
Der \texttt{Discovery::Locator} ist eine Klasse mit Elementen, die auf den genauen Fundort einer Georeferenz in einem Web-Dokument (oder ähnlichem) verweist. Ziel hierbei ist, im späteren Verlauf den Ursprung der Fundstelle maschinell oder durch den Menschen nachverfolgbar (oder belegbar, beispielsweise in einem journalistischen Anwendungsszenario) zu machen. Konkret beinhaltet die \texttt{Discovery::Locator}-Klasse die Felder \ldots

\begin{enumerate}
  \item{\texttt{url} um mit dort eine Resource im Internet unabhängig von einem konkreten Schema referenzieren zu können, sowie}
  \item{ein \texttt{byte\_offset}, um die konkrete Stelle im Dokument, das durch die URL referenziert ist, anzuzeigen, als auch}
  \item{einen \texttt{timestamp}, um den Zeitpunkt des Fundes festzuhalten.}
\end{enumerate}
  
Es existiert weiterhin ein optionales Feld \texttt{proof}, das die Fund-Webresource base64-enkodiert in Kopie vorhalten kann.

\subsection{Anwendungsfallspezifische Zusatzattribute}

Alle oben genannten Klassen enthalten beliebig viele weitere Attribute, die vom Namen her unterschiedlich zu den bereits vorgestellten Attributen sein müssen. Hier hat der Entwickler die Möglichkeit anwendungsspezifische Daten in die Datenstruktur einzubetten um beispielsweise Geokodierungsschritte oder Umwandlungen einzusparen oder zusätzliche Meta-Informationen mitzuliefern.

